#include <iostream>
#include <raylib.h>
#include <raymath.h>
#include <string.h>

const Vector2 WINDOW_SIZE = {1600, 900};

#define SIZE_X 50
#define SIZE_Y 25
#define SIZE_Z 25
const Vector3 WORLD_SIZE = {SIZE_X, SIZE_Y, SIZE_Z};
float world[3][SIZE_X][SIZE_Y][SIZE_Z];
int k[SIZE_X][SIZE_Y][SIZE_Z];

void init_world() {
  for (int x = 0; x < WORLD_SIZE.x; x++) {
    for (int y = 0; y < WORLD_SIZE.y; y++) {
      for (int z = 0; z < WORLD_SIZE.z; z++) {
        k[x][y][z] = 6;

        if (x == 0)
          k[x][y][z]--;
        if (y == 0)
          k[x][y][z]--;
        if (z == 0)
          k[x][y][z]--;

        if (x == WORLD_SIZE.x - 1)
          k[x][y][z]--;
        if (y == WORLD_SIZE.y - 1)
          k[x][y][z]--;
        if (z == WORLD_SIZE.z - 1)
          k[x][y][z]--;
      }
    }
  }

  world[0][(int)WORLD_SIZE.x / 2][(int)WORLD_SIZE.y / 2]
       [(int)WORLD_SIZE.z / 2] = 1;
}

void draw_world() {
  Color color;
  float p_norm;

  DrawCube({WORLD_SIZE.x / 2 - 0.5, WORLD_SIZE.y / 2 - 0.5, -1}, WORLD_SIZE.x,
           WORLD_SIZE.y, 1, GRAY);
  DrawCube({-1, WORLD_SIZE.y / 2 - 0.5, WORLD_SIZE.z / 2 - 0.5}, 1,
           WORLD_SIZE.y, WORLD_SIZE.z, GRAY);
  DrawCube({WORLD_SIZE.x / 2 - 0.5, -1, WORLD_SIZE.z / 2 - 0.5}, WORLD_SIZE.x,
           1, WORLD_SIZE.z, BROWN);
  DrawCubeWires({WORLD_SIZE.x / 2 - 0.5, WORLD_SIZE.y / 2 - 0.5, -1},
                WORLD_SIZE.x, WORLD_SIZE.y, 1, BLACK);
  DrawCubeWires({-1, WORLD_SIZE.y / 2 - 0.5, WORLD_SIZE.z / 2 - 0.5}, 1,
                WORLD_SIZE.y, WORLD_SIZE.z, BLACK);
  DrawCubeWires({WORLD_SIZE.x / 2 - 0.5, -1, WORLD_SIZE.z / 2 - 0.5},
                WORLD_SIZE.x, 1, WORLD_SIZE.z, BLACK);

  for (int x = 0; x < WORLD_SIZE.x; x++) {
    for (int y = 0; y < WORLD_SIZE.y; y++) {
      for (int z = 0; z < WORLD_SIZE.z; z++) {
        p_norm = Remap(world[0][x][y][z], -1, +1, -255, 255);
        p_norm = fmax(fmin(p_norm, 255), -255);

        if (p_norm >= 0)
          color = Color{0, 0, 150, static_cast<unsigned char>(p_norm)};
        else
          color = Color{0, 150, 0, static_cast<unsigned char>(-p_norm)};

        DrawCube({(float)x, (float)y, (float)z}, 1, 1, 1, color);
      }
    }
  }
}

void simulate() {
  const float courant = 1 / sqrt(3);
  const float reflection = 0;
  const float emittance = (1 + reflection) / (1 - reflection);

  memcpy(world[2], world[1],
         sizeof(float) * WORLD_SIZE.x * WORLD_SIZE.y * WORLD_SIZE.z);
  memcpy(world[1], world[0],
         sizeof(float) * WORLD_SIZE.x * WORLD_SIZE.y * WORLD_SIZE.z);

  // float n, b;
  // for (int x = 0; x < WORLD_SIZE.x; x++) {
  //   for (int y = 0; y < WORLD_SIZE.y; y++) {
  //     for (int z = 0; z < WORLD_SIZE.z; z++) {
  //       n = 0;
  //       if (x != WORLD_SIZE.x - 1)
  //         n += world[1][x + 1][y][z];
  //       if (y != WORLD_SIZE.y - 1)
  //         n += world[1][x][y + 1][z];
  //       if (z != WORLD_SIZE.z - 1)
  //         n += world[1][x][y][z + 1];
  //
  //       if (x != 0)
  //         n += world[1][x - 1][y][z];
  //       if (x != 0)
  //         n += world[1][x][y - 1][z];
  //       if (x != 0)
  //         n += world[1][x][y][z - 1];
  //
  //       b = (6 - k[x][y][z]) / (2 * emittance);
  //       world[0][x][y][z] =
  //           (1 / (1 + courant * b)) *
  //           (courant * courant * n +
  //            (2 - k[x][y][z] * courant * courant) * world[1][x][y][z] +
  //            (courant * b - 1) * world[2][x][y][z]);
  //     }
  //   }
  // }
  float n, b;
  for (int x = 1; x < WORLD_SIZE.x - 1; x++) {
    for (int y = 1; y < WORLD_SIZE.y - 1; y++) {
      for (int z = 1; z < WORLD_SIZE.z - 1; z++) {
        n = 0;

        n += world[1][x + 1][y][z];
        n += world[1][x][y + 1][z];
        n += world[1][x][y][z + 1];

        n += world[1][x - 1][y][z];
        n += world[1][x][y - 1][z];
        n += world[1][x][y][z - 1];

        world[0][x][y][z] = (1 / 3) * n - world[2][x][y][z];
      }
    }
  }
}

int main() {
  InitWindow(WINDOW_SIZE.x, WINDOW_SIZE.y, "licenta 3D");
  SetTargetFPS(60);

  init_world();
  std::cout << k[0][0][0] << " " << k[0][1][0] << " " << k[0][1][1] << " "
            << k[1][1][1] << std::endl;

  Camera camera = {
      .position = {(float)1.5 * WORLD_SIZE.x, (float)1.5 * WORLD_SIZE.y,
                   (float)1.5 * WORLD_SIZE.z},
      .target = {WORLD_SIZE.x / 2, WORLD_SIZE.y / 2, WORLD_SIZE.z / 2},
      .up = {0, 1, 0},
      .fovy = 60,
      .projection = CAMERA_PERSPECTIVE};

  while (!WindowShouldClose()) {
    // UpdateCamera(&camera, CAMERA_ORBITAL);

    simulate();

    BeginDrawing();
    ClearBackground(Color{135, 206, 235});

    BeginMode3D(camera);
    draw_world();
    EndMode3D();

    DrawFPS(30, 30);
    EndDrawing();
  }

  CloseWindow();
}
